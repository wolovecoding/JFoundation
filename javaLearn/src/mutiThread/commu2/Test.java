package mutiThread.commu2;

/**
 * @description:
 *
 *      功能： 生产者-消费者问题
 *      技能：线程通信  wait（）  notify（）   notifyAll()   Object类的public方法
 *
 *      业务分析：
 *      1. 生产和消费交替进行
 *      2. 生产者交替的生产白色馒头和黄色的玉米饼
 *      3. 生产者 ----- 仓库 ------ 消费者（仓库中只能存放一件商品）
 *
 *      注意：
 *      1.生产者线程和消费者线程是两个不同的线程
 *      2.之前的取款线程只要执行代码，不同线程之间没有通信
 *      3.现在的生产者线程、消费者线程需要相互通信
 *      4.同样也需要线程同步，保证线程安全性（线程通信的前提是线程同步）
 *
 *      类的设计：
 *      1.定义一个商品Product类
 *      2.定义两个线程：生产者线程、消费者线程
 *      3.定义测试类：创建线程并启动
 *
 *      问题1：  消费者没有消费生产者生产的馒头
 *      解决：注入。
 *
 *      问题2：生产者实现了交替，消费者没有实现交替
 *      原因：生产者交替的生产不同的商品，本质是修改Product的两个属性的值
 *              消费者消费的本质是输出Product当前的属性的值
 *          解决： 先加sleep使问题充分暴露；  发现出现 黄色的馒头  --》加锁。
 *     问题3：加锁后，问题没有解决，（我生产了一半，消费者可以消费）---》生产者消费者都加锁
 *              注意：不仅生产者需要加锁，消费者也要加锁，而且必须是同一把锁
 *                  正好使用共享资源做锁即可
 *     问题4：生产者已经交替，但消费者没有交替
 *
 *     线程同步通信细节：
 *
 *      先强调
 *          1.wait会进入阻塞状态并释放锁。
 *          2.wait的线程被唤醒之后，会执行后续代码，不会重新判断是否等待||除非while（）{wait（）}
 *          3.if（）{wait} 不要将后面的语句写入到else中
 *
 *      细节1：进行线程通信的多个线程，要使用同一个同步监视器（product），还必须要调用该同步监视器
 *          的wait（）、notify（）、notifyAll()方法
 *
 *     细节2：线程通信的三个方法
 *          wait（）等待
 *              在【其他线程】调用【此对象】的notify方法前，导致当前线程等待，当前线程必须拥有此对象监视器.
 *              换句话说，此方法的行为就好像他仅执行wait（0）调用一样。
 *              当前线程必须拥有此对象监视器。
 *         wait(time)等待
 *              在其他线程调用此对象的notify（）方法或notifyAll()方法，或者超过指定的时间量前，导致当前线程等待
 *              当前线程必须要有此对象监视器
 *
 *        notify（）通知唤醒
 *          唤醒在【此对象监视器】上等待的【单个】线程，
 *          如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，【选择是任意的】
 *       notifyAll（） 通知所有  唤醒所有
 *          唤醒在【此对象监视器】上等待的【所有】线程，
 *          被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程【进行竞争】
 *
 *    细节3：完整的线程周期  看图
 *
 *    细节4：sleep()和yield()的区别 ： sleep（）和wait（）的区别
 *      区别1：sleep（） 线程会让出CPU进入阻塞状态，但不会释放对象锁
 *              wait（）线程会让出CPU进入阻塞状态，【也会放弃对象锁】，进入等待【此对象】的等待锁定
 *     区别2：进入的阻塞状态也是不同的队列。（三种阻塞）
 *     区别3：wait只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
 * @author: wangzi
 * @time: 2021/4/24 17:24
 */
public class Test {
    public static void main(String[] args) {
        Product product = new Product();
        //创建两个线程对象
        Runnable pr = new ProduceRunnable(product);
        Runnable cr = new ConsumeRunnable(product);
        Thread pt = new Thread(pr);
        Thread ct = new Thread(cr);
        //启动线程
        pt.start();
        ct.start();

    }
}
